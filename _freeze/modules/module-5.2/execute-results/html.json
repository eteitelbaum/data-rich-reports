{
  "hash": "266cb14df40a75baadab4fc4c8622f5f",
  "result": {
    "markdown": "---\ntitle: \"Module 5.2\"\nsubtitle: \"Exploring Reactivity\"\nformat: \n  html:\n    code-link: true\nhighlight-style: atom-one\nexecute:\n  echo: true\n  message: false\n  warning: false\n---\n\n\n:::{.callout-tip}\n## Prework\n- Get a [FRED API key](https://fred.stlouisfed.org/docs/api/api_key.html)\n- Install [fredr](https://cran.r-project.org/web/packages/fredr/vignettes/fredr.html) and read about its basic usage\n- Install [ecm](https://cran.r-project.org/web/packages/ecm/ecm.pdf), which we will use to build our recession shading helper script\n- Install [shinyWidgets](https://dreamrs.github.io/shinyWidgets/) and familiarize yourself with its basic functions\n- Start a new Shiny project for this lesson. Go to File, select New Directory and then Shiny App. Browse to where you want to save the app, give the directory a name and click Create Project. \n:::\n\n## Overview\n\nA fundmental concept in R Shiny is reactivity. Reactivity refers to the automatic responsiveness and dynamic behavior of the application based on user input and data changes. It allows the application to update and re-render specific parts of the user interface (UI) in response to changes in input values, data updates, or other reactive triggers.\n\nAll Shiny apps have an element of reactivity. In a basic Shiny app like we say in the last module, reactivity occurs when user input is fed to the server function through functions like `renderPlot()` or `renderTable()`. But we might also want to add additional elements of reactivity by using reactive functions like `reactive()` or `observe()`. In this lesson, we are going to look at how to use the `reactive()` function to control two separate reactive inputs to a line chart: the indicator the user wishes to view and the date range that the way to view it for. Here is the app that we are going to be building:\n\n<iframe src=\"https://emmanuelteitelbaum.shinyapps.io/fred_app/\" width=\"780\" height=\"560\" data-external=\"1\"></iframe>\n\n## Setup\n\n{{< video https://www.youtube.com/embed/wo9vZccmqwc title = 'fredr App set up'>}}\n\nIn the setup portion of our we want to start by loading the packages we will need to build the app. For this app, we are going to be using the `fredr` package to download data pertaining to the overall health of the economy from the St. Louis Fed API (FRED). So here we will also set our FRED API key and assign the codes for the indicators that we want to download to objects. \n\nNext, we will use the `as.Date()` function to set the start date of our line series to Januar 1, 1970 and the end date as today's date (system date). We will also create a list of variable names for our UI dropdown (`vars`) and relate them to the objects containing the indicator codes. \n\nFinally, we are going to be using a helper function to generate recession shading for our charts. Scroll down to the bottom of this page to see the code for the helper function. Take this and save it in an R file and put it in your app folder. In this chunk, we are going to call it with the source function, e.g. `source(helper.R)`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(shiny)\nlibrary(fredr)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# Set Fred API key \nfredr_set_key(\"YOUR FRED API KEY\") \n\n# Assign FRED series to objects\ncci <- \"CSCICP03USM665S\" # consumer confidence\nbci <- \"BSCICP03USM665S\" # business confidence\ncli <- \"USALOLITONOSTSAM\" # composite lead indicator\nunemp_rate <- \"UNRATE\" # unemployment rate\ngrowth <- \"A191RL1Q225SBEA\" # growth rate\n\n# set start and end date\nstart_date <- as.Date(\"1970-01-01\")\nend_date <- as.Date(Sys.Date())\n\n# Create list of named values for the input selection\nvars <- c(\"Consumer Confidence\" = cci, \n          \"Business Confidence\" = bci, \n          \"Composite Indicator\" = cli, \n          \"Unemployment Rate\" = unemp_rate,\n          \"Growth Rate\" = growth)\n\n# Load helper script\nsource(\"helper.R\") # scroll down, code pasted below\n```\n:::\n\n\n## UI\n\n{{< video https://www.youtube.com/embed/wo9vZccmqwc title = 'fredR App user interface (UI)'>}}\n\nNow we can get started on developing the UI for our app. For this app, we are going to have a title panel and two main display elements. The first is a panel where the user can select the indicator that they want to chart and the second is a plot with a slider where users can select the years they want to view. So let's divide the UI into two sections using the `fluidRow()` and `column()` \n\nThe `fluidRow()` function creates horizontal containers while the `column()` function is used to create vertical containers. Since we our app is going to display a single row, we will have just one `fluidRow()` call. Then we can divide that row into two columns using the `column()` function. The first argument in `column()`is the column width. Since column widths in Shiny are based on the Boots Bootstrap 12-wide grid system, our column widths must add up to 12. So let's make our panel for selecting the indicator 4 units wide and the area where we will display the plot 8 units wide. \n\nFrom there, we can define the panel as a `wellPanel()` to give it an inset look and a grey background. We include `selectInput()` to get our dropdown where users can select an indicator from the `vars` list. Let's also use the `helpText()` function to display some instructions regarding how to use the app. \n\nFor the main display section, we are going to have our plot out along with the slider input. We are going to call this input \"range\" and leave the label blank. Then we need to define a min value, a max value and a range for the slider. For `min` and `max`, we will use `start_date` and `end_date`, which we defined earlier in the setup and the combination of these to define the range (`value`). Then we set `width` to 100% because we want the slider to expand to fit the entire width of the plot. `  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n\n    # Application title\n    titlePanel(\"FRED Data App\"),\n    \n    fluidRow(\n      \n      # 12 columns on one row: this panel will take 1/3 of it\n      column(4, wellPanel(\n        selectInput(\"indicator\", \"Indicator:\", vars)\n        ),\n      helpText(\"Select an indicator, choose a date range and view the trend. \n               The grey bars represent economic recessions. \n               The data for this app comes from the St. Louis Fed's \n               FRED database. The consumer confidence, business confidence and \n               lead composite indicators are OECD data downloaded through FRED.\")\n      ), \n      \n      # Remaining 2/3 occupied by plot\n      column(8,\n        plotOutput(\"lineChart\"),     \n        sliderInput(\n          \"range\",\n          \"\",\n          min = start_date,\n          max = end_date, \n          value = c(start_date, end_date), \n          width = \"100%\"\n        )\n      )\n    )\n)\n```\n:::\n\n\n\n## Server\n\n{{< video https://www.youtube.com/embed/wo9vZccmqwc title = 'fredR App Server'>}}\n\nFor our server function, we are going to define two separate `reactive()` functions. This is how we are going to dynamically update the plot based on two different user inputs. First, we will define an input for the indicator where `input$indicator` takes the user input from the dropdown menu to perform a fresh API call whenever the selected indicator changes. Then, we take that input and filter it based on the input from the slider, e.g. `input$range`. Then we render the plot based on these updated data. \n\nNotice that whenever we want to use the stored data from the reactive calls we need to add parentheses after the objects, e.g. `fred_indicator()` in the second reactive function or `fred_data()` in the `ggplot` call. This is to ensure that the reactive expression is evaluated and its current value is used as the input data for the plot. \n\nFinally, we are going to use the `add_rec_shade()` helper function to add the recession shading to the chart. We again use the inputs from the two reactive functions to define the start date and end date of the shading as well as the y-min and y-max values of the shaded rectangles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output) {\n  \n    # Download data from FRED with reactive function. \n    # Only updates when user selects new indicator\n    fred_indicator <- reactive({\n      fredr(series_id = input$indicator,\n        observation_start = start_date,\n        observation_end = end_date)\n    })\n  \n    # Filter data according to chosen years \n    # Only updates when user selects new data range\n    fred_data <- reactive({\n      fred_indicator() |>\n      filter(between(date, input$range[1],input$range[2])) \n   })\n\n    # Render line chart\n    output$lineChart <- renderPlot({\n      \n      # Build plot with ggplot2\n      ggplot(fred_data(), aes(x = date, y = value)) + \n        geom_line(color = \"navyblue\") +\n        labs(\n          x = \"\", \n          y =  names(vars[which(vars == input$indicator)])\n        ) +\n        theme_minimal() +\n        # add recession shading\n        add_rec_shade(st_date = input$range[1], \n                      ed_date = input$range[2], \n                      shade_color = \"darkgrey\",\n                      y_min = min(fred_data()$value),\n                      y_max = max(fred_data()$value))\n    })\n}\n```\n:::\n\n\n\n## Call to Shiny app\n\nOnce we have our UI and server functions defined we are ready to go. But don't forget to include the call to the Shiny app or the app won't run! Once this is in place, you can click \"Run App\" in the RStudio IDE to view the app locally. Optionally, right now, you can try setting up an account on [shinyapps.io](https://www.shinyapps.io/) and try publishing your app on their server. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# See above for the definitions of ui and server\nui <- ...\n\nserver <- ...\n\n# Run the application \nshinyApp(ui = ui, server = server)\n```\n:::\n\n\n## Helper script\n\nThis is the helper script for shaded recession rectangles. Save in a file called `helper.R` in same folder as your `app.R` file. See [this post](https://rpubs.com/FSl/609471) for more details. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ecm) # forlagpad\n\n# define add_rec_shade function\nadd_rec_shade<-function(st_date,ed_date,shade_color, y_min, y_max) {\n  \n  # download NBER recession indicators, peak through trough\n  recession<- fredr(series_id = \"USRECD\",\n                    observation_start = st_date,\n                    as.Date(st_date), \n                    observation_end = as.Date(ed_date))\n  \n  #code 1 for 1st day of recession, -1 for 1st day after it ends\n  recession$diff<-recession$value-lagpad(recession$value,k=1)\n  \n  #drop 1st N.A. value\n  recession<-recession[!is.na(recession$diff),] \n  \n  #create vector of recession start dates\n  recession.start<-recession[recession$diff==1,]$date \n  \n  #create vector of recession end dates\n  recession.end<-recession[recession$diff==(-1),]$date \n  \n  # if there are more dates listed in recession.start than recession.end\n  if(length(recession.start)>length(recession.end))\n  # then enter system date for last date in recession.end\n  {recession.end<-c(recession.end,Sys.Date())} \n  \n  # if there are more dates listed in recession.end than recession.start\n  if(length(recession.end)>length(recession.start))       \n  # then enter the earliest date in recession$date as first date in recession.start  \n  {recession.start<-c(min(recession$date),recession.start)} \n  \n  # make a dataframe out of recession.start and recession.end\n  recs<-as.data.frame(cbind(recession.start,recession.end))\n  \n  # convert recession.start into a date\n  recs$recession.start<-as.Date(\n    as.numeric(recs$recession.start),\n    origin=as.Date(\"1970-01-01\")) \n\n  # convert recession.end into a date\n  recs$recession.end<-as.Date(\n    recs$recession.end,\n    origin=as.Date(\"1970-01-01\")) \n  \n  # if the number of rows in recs > 0\n  if(nrow(recs)>0) \n  # draw the rectangle  \n  {rec_shade<-geom_rect(data=recs, \n                         # inherit.aes=F overrides default aesthetics\n                         inherit.aes=F, \n                         aes(xmin=recession.start, \n                         xmax=recession.end, \n                         ymin=y_min, ymax=y_max), \n                         fill=shade_color, alpha=0.5)\n    return(rec_shade)\n  }\n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}