{
  "hash": "e78db94796610186df51b17a4a5d1fac",
  "result": {
    "markdown": "---\ntitle: \"Module 6.1\"\nsubtitle: \"Building Your App\"\nformat: \n  html:\n    code-link: true\nhighlight-style: atom-one\nexecute:\n  echo: true\n  message: false\n  warning: false\n---\n\n\nBy now you should have a good sense of what kind of app you want to\ncreate for your final project. In this module, I want to walk you\nthrough the process of executing your plan and give you some general\ntips on how to work out potential bugs in your app. I would also point\nyou to this [Shiny\ncheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/shiny.pdf).\n\nOne key piece of advice I will offer is to scaffold the construction of\nyour app. Don't try to write all of the code at once. This is especially\ntrue if you have a lot of moving parts to your app. Start with small,\nworkable parts and build on them.\n\n{{< video https://youtu.be/wo9vZccmqwc title = 'Building your app'>}}\n\n## 1. Wrangle some \"working data\"\n\nThe first thing you want to do is to wrangle some of the data that you\nneed for the app. Crucially, you do not need to wrangle all of the data\nat first.\n\nLet's assume for a second, that you want to have an app that builds a\nscatter plot looking at the relationship between measures of democracy\nand governance from V-Dem and a large number of development indicators\nfrom WDI. You could go ahead and wrangle all of the data from both data\nsets and merge it or you could start out with a small number of V-Dem or\nWDI indicators to work with. I would encourage you to use a smaller\nnumber of indicators as a proof of concept. Then, go back and merge in\nmore data when you know your app works.\n\n## 2. Use separate files to wrangle your data and build your visualizations\n\nStart the process of wrangling your data in a separate R script or\nQuarto document rather than trying to do it all in your `app.R` file.\nUse `glimpse()` and `View()` to make sure that your data looks like it\nshould. This sounds basic, but a lot the errors you are going to get in\nyour app are going to come from bad data. Similarly, use a separate file\nto test your visualization or analysis with one or a handful of\nindicators to make sure the basic code is working properly.\n\n## 3. Start building with comments and function calls\n\nAgain in the spirit of scaffolding your code, start by writing out\ncomments stating what you want each section of the code to do and then\nintroduce the function calls without any arguments. This can give you a\nclear picture of the basic components and architecture of your app. it\ncan also help to make sure that you have all of your parentheses and\nbrackets in the right place. Here is an example based on the scatter\nplot app that we built in an earlier module:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n\n# load packages\nlibrary(shiny)\nlibrary(readr)\nlibrary(ggplot2)\n\n# load the data\ndem_data <- read_csv()\n\n# Create list of named values for the input selection\nvars <- c()\n\n# Define UI for application that draws a histogram\nui <- fluidPage(\n\n    # Application title\n    titlePanel(),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n      sidebarPanel(\n        selectInput(),\n        selectInput()\n      ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n           plotOutput()\n        )\n    )\n)\n\n# Define server logic required to draw a scatter plot\nserver <- function(input, output, session) {\n  \n  # Render the plot output\n  output$scatterplot <- renderPlot({\n\n   })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n```\n:::\n\n\n## 4. Test your UI code separately from your server code\n\nOnce you have your UI code built, try running it with a blank server\nfunction or commenting out the \"guts\" of the server function. You should\nbe able to see whether the inputs like drop-down menus, sliders, check\nboxes and radio buttons are in the right place and working properly.\nHere is an example from our earlier scatter plot app:\n\n::: callout-note\nYou can comment out multiple lines of code by highlighting them and\nhitting **ctrl + shift + c** on a PC or **command + shift + c** on a\nMac.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n\n# load packages\nlibrary(shiny)\nlibrary(readr)\nlibrary(ggplot2)\n\n# load the data\ndem_data <- read_csv(\"dem_data.csv\")\n\n# Create list of named values for the input selection\nvars <- c(\"Democracy\" = \"polyarchy\",\n          \"Clientelism\" = \"clientelism\",\n          \"Corruption\" = \"corruption\",\n          \"Women's Empowerment\" = \"womens_emp\",\n          \"Wealth\" = \"gdp_pc\",\n          \"Infant Mortality\" = \"inf_mort\",\n          \"Life Expectancy\" = \"life_exp\", \n          \"Education\" = \"education\")\n\n# Define UI for application that draws a histogram\nui <- fluidPage(\n\n    # Application title\n    titlePanel(\"Democracy and Development\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n      sidebarPanel(\n        selectInput('xcol', 'X Variable', vars),\n        selectInput('ycol', 'Y Variable', vars, selected = vars[[6]])\n      ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n           plotOutput(\"scatterplot\")\n        )\n    )\n)\n\n# Define server logic required to draw a scatter plot\nserver <- function(input, output, session) {\n  \n  # # Render the plot output\n  # output$scatterplot <- renderPlot({\n  # \n  #   # Build scatter plot with ggplot2\n  #   ggplot(dem_data, aes(x = get(input$xcol), y = get(input$ycol))) +\n  #     geom_point(aes(color = region)) +\n  #     geom_smooth(method = \"loess\") +\n  #     scale_color_viridis_d(option = \"plasma\") +\n  #     theme_minimal() +\n  #     labs(\n  #       x =  names(vars[which(vars == input$xcol)]), # select names in vars that\n  #       y =  names(vars[which(vars == input$ycol)]), # match input selections\n  #       caption = \"Source: V-Dem Institute\",\n  #       color = \"Region\" \n  #     )\n  #  })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n```\n:::\n\n\n## 5. Make sure your reactive data frames have parentheses after them\n\nIf you are building a data frame with a `reactive()` function, then you\nneed to add parentheses after the name of the data frame when you\nreference it later. For example, in the line chart app that we did\nearlier in the course, we used a reactive function to download an\nindicator from the FRED database and store these data in an object\ncalled `fred_indicator`. But when we wanted to filter those data later\non in a second reactive function, we referred to them as\n`fred_indicator()`.\n\n## 6. Make sure that you are calling the input appropriately\n\nThink about where your server function needs to use the input from the\nuser. Then, when you are calling the input, make sure you are using the\nappropriate name for the input. For example, in our scatter plot app, we\ntook input from the user for two selected indicators (`input$xcol` and\n`input$ycol`) and used these to make a scatter plot.\n\n## 7. Consider nonstandard evaluation when using ggplot\\`\n\nConsider the fact that `ggplot2` uses nonstandard evaluation and wrap\nthe inputs in your `aes()` call in `get()` where appropriate.\nNonstandard evaluation refers to the idea that `ggplot2` takes the name\nof the column directly so that you don't have to quote it. `get()`\ntransforms the text input from the user to the actual column name. For\nexample, in our scatter plot app we used `get()` to transform the user\ninput to column names for our x and y variables:\n`ggplot(dem_data, aes(x = get(input$xcol), y = get(input$ycol)))`.\n\n## 8. In the server code, use `print()` to debug\n\nSometimes it is hard to tell if your reactive functions are producing\nthe output you want. One trick is to use `print()` or `glimpse()` in\nyour output function to see what is going on. This should produce the\noutput of the reactive function in your console. Here is an example from\nour line chart app:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the server function\n\nserver <- function(input, output) {\n  \n  # Download data from FRED with reactive function.\n  # Only updates when user selects new indicator\n  fred_indicator <- reactive({\n    fredr(series_id = input$indicator,\n          observation_start = start_date,\n          observation_end = end_date)\n    \n  })\n  \n  # Filter data according to selected years\n  # Only updates when user selects new date range\n  fred_data <- reactive({\n    fred_indicator() |>\n      filter(between(date, input$range[1], input$range[2]))\n  })\n  \n  # Render line chart\n  output$lineChart <- renderPlot({\n    \n    print(fred_data(), n = 100)   ####  USE print() TO VIEW OUTPUT IN CONSOLE \n    #glimpse(fred_data())         ####  ALTERNATIVELY, USE glimpse()  \n    \n    # Build plot with ggplot2\n    ggplot(fred_data(), aes(x = date, y = value)) +\n      geom_line(color = \"navyblue\") +\n      labs(\n        x = \"\",\n        y = names(vars[which(vars == input$indicator)])\n      )+\n      theme_minimal() +\n      # add recession shading\n      add_rec_shade(st_date = input$range[1],\n                    ed_date = input$range[2],\n                    shade_color = \"darkgrey\",\n                    y_min = min(fred_data()$value),\n                    y_max = max(fred_data()$value))\n    })\n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}